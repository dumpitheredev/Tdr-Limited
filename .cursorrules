# Project Overview
1. Build a responsive, maintainable UI using Bootstrap 5.3 with minimal custom CSS.
2. Use Flask for backend operations, including authentication, SMTP-based email notifications, and MySQL CRUD.
3. Start with a static front end (mock data in UI), then integrate Flask routes and database logic.
4. all button color should be 191970 and all h1 h2 in the main content should be 191970

# Structure & Components
4. Organize files into clear folders (templates, static/css, static/js, static/assets).
5. Use Flask's templating (render_template, Jinja includes) for reusable components (header, sidebar, footer, modals).
6. Keep each layout element in its own partial or component file (e.g., _header.html).

# Flask Integration
7. Create a Flask app (e.g., app.py) with Blueprints for modular routing (user, class, attendance).
8. Store DB credentials and SMTP settings in config or environment variables (never hardcode).
9. Test with mock data initially; switch to live MySQL queries and actual email sending once the UI is stable.

# Authentication & SMTP
10. Implement secure user authentication with Flask-Login or a similar library (login, logout, session management).
11. For password resets or notifications, configure Flask-Mail (SMTP) with correct server and port.
12. Ensure sensitive info (SMTP password, tokens) is kept in environment variables or a secure config file.
13. Use route decorators (@login_required) for pages requiring authentication.

# MySQL & Database
14. Use a Flask MySQL extension or SQLAlchemy to manage database connectivity.
15. Implement CRUD (Create, Read, Update, Delete) in a separate data-access layer or models.py file.
16. Replace mock data in the templates with real DB data after verifying UI.

# Bootstrap Usage
17. Use the Bootstrap grid system (container, row, col-*-*) and utility classes (p-*, m-*, text-*).
18. For form validation, apply Bootstrap's is-invalid and invalid-feedback classes.
19. Use data-bs-* attributes for modals, tooltips, and offcanvas components.

# JavaScript Conventions
20. Name event handlers with a "handle" prefix (handleFormSubmit, handleUserLogin).
21. Rely on early returns to reduce nesting in JS functions.
22. Keep scripts in static/js; link them in templates via url_for('static', filename='js/...').

# Accessibility
23. Provide ARIA attributes, roles, and labels for interactive elements (aria-label="Close", role="button").
24. Verify proper tab order and keyboard navigation for modals and forms.
25. Use semantic HTML (header, nav, main) to improve screen-reader support.

# Performance & Maintenance
26. Load Bootstrap and optional libraries from a CDN; import only required components.
27. Minify CSS/JS in production; store images in static/assets, optimized for size.
28. Set up logging for both Flask errors and SMTP failures.

# Final Notes
29. Adhere to DRY principles and use standard Bootstrap design patterns across pages.
30. Validate your front-end with mock data before connecting Flask routes for auth, MySQL, and SMTP.
31. Thoroughly test authentication flows, email sending, and database CRUD before production deployment.

commit_on_save:
  enabled: true
  message_template: "auto: {filename} - {changes}"

commit_message_validation:
  enabled: true
  pattern: "^(feat|fix|docs|style|refactor|test|chore|auto):"

auto_commit_empty_messages: true
